<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"/>
<title>Brick Breaker+ (Mobile Launch Fixed)</title>
<style>
  :root{
    --bg:#0b0f17; --panel:#121a27; --line:#223049;
    --text:#e7eefc; --muted:#9bb0d0;
    --shadow:0 14px 34px rgba(0,0,0,.35); --r:18px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text);
    font-family: system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR","맑은 고딕",sans-serif;
    background:
      radial-gradient(1200px 700px at 20% 0%, rgba(96,165,250,.25), transparent 60%),
      radial-gradient(900px 600px at 90% 15%, rgba(52,211,153,.18), transparent 55%),
      radial-gradient(900px 600px at 60% 100%, rgba(251,191,36,.12), transparent 55%),
      var(--bg);
    overscroll-behavior:none;
    touch-action: manipulation;
  }

  .wrap{max-width:1100px; margin:0 auto; padding:14px}
  header{
    display:flex; align-items:center; justify-content:space-between; gap:12px;
    margin:10px 0 12px;
  }
  .brand{display:flex; align-items:center; gap:10px}
  .logo{
    width:44px;height:44px;border-radius:14px;
    background:linear-gradient(145deg, rgba(96,165,250,.9), rgba(52,211,153,.85));
    display:grid;place-items:center;font-weight:900; box-shadow: var(--shadow);
  }
  h1{margin:0; font-size:18px}
  .sub{font-size:12px; color:var(--muted); margin-top:2px}

  .top{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; align-items:center}
  button, select{
    border:1px solid #223049;
    background: rgba(18,26,39,.78);
    color:#e7eefc;
    padding:10px 12px; border-radius:14px;
    cursor:pointer; user-select:none;
    transition:.15s transform,.15s filter;
  }
  select{cursor:pointer}
  button:hover, select:hover{filter:brightness(1.06)}
  button:active{transform:translateY(1px) scale(.99)}
  .btn-accent{border-color: rgba(96,165,250,.55); background: linear-gradient(145deg, rgba(96,165,250,.35), rgba(18,26,39,.85))}
  .btn-good{border-color: rgba(52,211,153,.55); background: linear-gradient(145deg, rgba(52,211,153,.28), rgba(18,26,39,.85))}
  .btn-warn{border-color: rgba(251,191,36,.55); background: linear-gradient(145deg, rgba(251,191,36,.22), rgba(18,26,39,.85))}

  .grid{display:grid; grid-template-columns: 1.15fr .85fr; gap:14px}
  @media (max-width:980px){ .grid{grid-template-columns:1fr} }

  .card{
    background: linear-gradient(180deg, rgba(18,26,39,.92), rgba(15,22,34,.92));
    border:1px solid #223049;
    border-radius: var(--r);
    box-shadow: var(--shadow);
    padding:12px;
    overflow:hidden;
  }

  .stage{display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start}
  .canvasWrap{width: min(520px, 100%)}

  /* 핵심: 인앱 WebView에서도 높이 0 되는 문제 방지 → JS가 픽셀로 강제 세팅 */
  canvas{
    width:100%;
    height: 520px;         /* JS가 덮어씀 */
    background: rgba(0,0,0,.16);
    border:1px solid rgba(255,255,255,.08);
    border-radius: 16px;
    display:block;
    touch-action:none;     /* 캔버스 터치 스크롤 충돌 방지 */
  }

  .side{flex:1; min-width:240px; display:flex; flex-direction:column; gap:10px}
  .panel{
    background: rgba(0,0,0,.16);
    border:1px solid rgba(255,255,255,.08);
    border-radius: 16px;
    padding:10px 12px;
  }
  .stats{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
  .stat{padding:10px 12px; border-radius:16px; background: rgba(0,0,0,.18); border:1px solid rgba(255,255,255,.06)}
  .k{font-size:12px; color:var(--muted)}
  .v{font-size:18px; font-weight:900; margin-top:4px}
  .row2{display:flex; gap:10px; flex-wrap:wrap}
  .pill{
    font-size:12px; padding:6px 10px; border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.18);
    color: var(--muted);
    white-space:nowrap;
  }
  .hint{font-size:12px; color:var(--muted); line-height:1.55}
  .log{
    height: 360px; overflow:auto;
    margin-top:10px;
    white-space:pre-line;
    color: rgba(231,238,252,.88);
  }
  .pad{
    background: rgba(0,0,0,.16);
    border:1px solid rgba(255,255,255,.08);
    border-radius: 16px;
    padding:10px;
  }
  .pad b{display:block; font-size:12px; color:var(--muted); margin-bottom:8px}
  .pad .btns{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px}
  .pad button{padding:12px 10px; font-weight:900}
  .pad .wide{grid-column: span 3}

  .toast{
    position:fixed; left:50%;
    bottom: calc(18px + env(safe-area-inset-bottom));
    transform:translateX(-50%);
    background: rgba(15,22,34,.92);
    border:1px solid rgba(255,255,255,.10);
    padding:10px 12px; border-radius:14px;
    box-shadow: var(--shadow);
    opacity:0; pointer-events:none;
    transition:.2s opacity,.2s transform;
    font-size:12px;
    max-width:min(760px, calc(100vw - 30px));
  }
  .toast.on{opacity:1; transform:translateX(-50%) translateY(-2px)}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="logo">B</div>
      <div>
        <h1>Brick Breaker+</h1>
        <div class="sub">모바일 발사(Launch) 문제 해결 버전 — 캔버스 탭 = 발사</div>
      </div>
    </div>

    <div class="top">
      <select id="themeSelect" title="테마 선택"></select>
      <button class="btn-accent" id="btnStart">시작</button>
      <button id="btnPause">일시정지</button>
      <button class="btn-good" id="btnNew">새 게임</button>
      <button class="btn-warn" id="btnResetBest">기록 초기화</button>
    </div>
  </header>

  <div class="grid">
    <section class="card">
      <div class="stage">
        <div class="canvasWrap">
          <canvas id="cv" width="900" height="1200" aria-label="brick breaker"></canvas>
        </div>

        <div class="side">
          <div class="panel">
            <div class="stats">
              <div class="stat"><div class="k">점수</div><div class="v" id="score">0</div></div>
              <div class="stat"><div class="k">최고</div><div class="v" id="best">0</div></div>
              <div class="stat"><div class="k">레벨</div><div class="v" id="level">1</div></div>
              <div class="stat"><div class="k">라이프</div><div class="v" id="life">3</div></div>
            </div>
            <div style="height:10px"></div>
            <div class="row2">
              <span class="pill" id="statePill">대기</span>
              <span class="pill" id="buffPill">버프: -</span>
              <span class="pill" id="speedPill">속도: -</span>
              <span class="pill" id="dropsPill">드랍률</span>
            </div>
          </div>

          <div class="panel">
            <div class="hint">
              ✅ 모바일: <b>캔버스 “톡” 탭</b> = 시작+발사<br/>
              ✅ 모바일: <b>드래그</b>로 패들 이동<br/>
              ✅ 버튼 발사도 지원(인앱 click 씹힘 대비해 touchstart 포함)
            </div>
          </div>

          <div class="pad">
            <b>모바일 버튼</b>
            <div class="btns">
              <button id="btnLeft">←</button>
              <button id="btnShoot">발사</button>
              <button id="btnRight">→</button>
              <button id="btnLaser">레이저</button>
              <button class="wide btn-accent" id="btnRestart">새공/재시작</button>
            </div>
          </div>

          <div class="panel">
            <div class="hint">• 테마 저장(localStorage) • 캔버스 높이는 JS 자동 맞춤</div>
          </div>
        </div>
      </div>
    </section>

    <aside class="card">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px">
        <div style="font-weight:900">플레이 로그</div>
        <span class="pill" id="pillInfo">모바일 런치 패치</span>
      </div>
      <div class="log" id="log"></div>
    </aside>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
(() => {
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const $ = (id)=>document.getElementById(id);

  const scoreEl = $("score");
  const bestEl  = $("best");
  const levelEl = $("level");
  const lifeEl  = $("life");
  const statePill = $("statePill");
  const buffPill  = $("buffPill");
  const speedPill = $("speedPill");
  const dropsPill = $("dropsPill");
  const logEl = $("log");
  const toastEl = $("toast");
  const themeSelect = $("themeSelect");

  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add("on");
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(()=>toastEl.classList.remove("on"), 1700);
  }
  function log(msg){
    const t = new Date().toLocaleTimeString("ko-KR",{hour:"2-digit",minute:"2-digit",second:"2-digit"});
    const prev = logEl.textContent;
    logEl.textContent = `[${t}] ${msg}\n` + prev;
    logEl.textContent = logEl.textContent.slice(0, 2600);
  }

  // ===== 캔버스 CSS 높이 모바일에서 강제 세팅 (dvh/vh 버그 방지) =====
  function fitCanvasCssHeight(){
    const vh = Math.max(320, window.innerHeight || document.documentElement.clientHeight || 640);
    const h = Math.min(Math.round(vh * 0.70), 560);
    cv.style.height = h + "px";
  }
  window.addEventListener("resize", fitCanvasCssHeight);
  window.addEventListener("orientationchange", ()=>setTimeout(fitCanvasCssHeight, 120));
  fitCanvasCssHeight();

  // ===== Save (best + theme) =====
  const LS = "brick_breaker_plus_mobile_launchfix_v1";
  let best = 0;
  let savedTheme = "neo";
  try{
    const raw = localStorage.getItem(LS);
    if(raw){
      const s = JSON.parse(raw);
      best = Math.max(0, (s.best|0));
      if(typeof s.theme === "string") savedTheme = s.theme;
    }
  }catch(e){}
  let themeId = savedTheme;

  function saveAll(){
    try{ localStorage.setItem(LS, JSON.stringify({best, theme: themeId})); }catch(e){}
  }

  // ===== Themes =====
  const THEMES = [
    { id:"neo", name:"네온", boardBG:"rgba(0,0,0,.12)", frame:"rgba(255,255,255,.08)",
      paddle:"#e7eefc", paddleGlow:"rgba(96,165,250,.22)",
      ball:"rgba(52,211,153,.95)", ballGlow:"rgba(255,255,255,.20)",
      laser:"rgba(167,139,250,.92)", shield:"rgba(56,189,248,.55)",
      brickPal:["rgba(96,165,250,.82)","rgba(52,211,153,.82)","rgba(251,191,36,.85)","rgba(251,113,133,.86)"],
      steel:"rgba(148,163,184,.85)", glass:"rgba(196,181,253,.80)"
    },
    { id:"retro", name:"레트로", boardBG:"rgba(0,0,0,.18)", frame:"rgba(34,197,94,.18)",
      paddle:"rgba(226,232,240,.92)", paddleGlow:"rgba(34,197,94,.18)",
      ball:"rgba(34,197,94,.92)", ballGlow:"rgba(255,255,255,.14)",
      laser:"rgba(34,197,94,.92)", shield:"rgba(34,197,94,.45)",
      brickPal:["rgba(34,197,94,.72)","rgba(59,130,246,.65)","rgba(245,158,11,.72)","rgba(239,68,68,.70)"],
      steel:"rgba(100,116,139,.78)", glass:"rgba(148,163,184,.55)"
    },
    { id:"noir", name:"노아르", boardBG:"rgba(0,0,0,.22)", frame:"rgba(255,255,255,.10)",
      paddle:"rgba(231,238,252,.92)", paddleGlow:"rgba(255,255,255,.10)",
      ball:"rgba(231,238,252,.85)", ballGlow:"rgba(255,255,255,.18)",
      laser:"rgba(231,238,252,.85)", shield:"rgba(231,238,252,.25)",
      brickPal:["rgba(231,238,252,.45)","rgba(231,238,252,.33)","rgba(231,238,252,.24)","rgba(231,238,252,.18)"],
      steel:"rgba(231,238,252,.40)", glass:"rgba(231,238,252,.22)"
    }
  ];
  if(!THEMES.some(t=>t.id===themeId)) themeId = "neo";
  const themeObj = ()=>THEMES.find(t=>t.id===themeId) || THEMES[0];

  for(const t of THEMES){
    const opt = document.createElement("option");
    opt.value = t.id;
    opt.textContent = t.name;
    themeSelect.appendChild(opt);
  }
  themeSelect.value = themeId;
  themeSelect.addEventListener("change", ()=>{
    themeId = themeSelect.value;
    saveAll();
    toast(`테마: ${themeObj().name}`);
  });

  // ===== Game Constants =====
  const W = cv.width, H = cv.height;

  // ===== State =====
  let running=false, paused=false, over=false;
  let score=0, level=1, life=3;

  const paddle = { x: W/2, y: H-90, w: 180, h: 18, speed: 900 };
  let paddleTargetX = paddle.x;

  let balls = [];
  let bricks = [];
  let drops = [];
  let lasers = [];

  const buffs = {
    expand: { on:false, t:0 },
    slow:   { on:false, t:0 },
    laser:  { on:false, t:0, ammo:0 },
    shield: { on:false, t:0 }
  };

  let dropRate = 0.18;
  let brickHPMax = 1;
  let ballSpeedBase = 560;
  let speedMult = 1;

  const keys = new Set();
  let lastTs = performance.now();

  const clamp = (v,a,b)=>Math.max(a, Math.min(b, v));
  const rand = (a,b)=>a + Math.random()*(b-a);

  function renderHUD(){
    scoreEl.textContent = score|0;
    bestEl.textContent = best|0;
    levelEl.textContent = level|0;
    lifeEl.textContent = life|0;

    const active = [];
    if(buffs.expand.on) active.push(`확장 ${Math.ceil(buffs.expand.t/1000)}s`);
    if(buffs.slow.on) active.push(`슬로우 ${Math.ceil(buffs.slow.t/1000)}s`);
    if(buffs.laser.on) active.push(`레이저 ${buffs.laser.ammo}`);
    if(buffs.shield.on) active.push(`쉴드 ${Math.ceil(buffs.shield.t/1000)}s`);
    buffPill.textContent = "버프: " + (active.length? active.join(" · ") : "-");

    speedPill.textContent = `속도: x${speedMult.toFixed(2)}`;
    dropsPill.textContent = `드랍률: ${(dropRate*100).toFixed(0)}%`;
  }

  function resetBall(){
    balls = [{ x:paddle.x, y:paddle.y-24, r:10, vx:0, vy:0, stuck:true }];
  }

  function clearAll(){
    bricks=[]; drops=[]; lasers=[]; balls=[];
    buffs.expand.on=buffs.slow.on=buffs.laser.on=buffs.shield.on=false;
    buffs.expand.t=buffs.slow.t=buffs.laser.t=buffs.shield.t=0;
    buffs.laser.ammo=0;
    speedMult = 1;
    paddle.w = 180;
    paddle.x = W/2;
    paddleTargetX = paddle.x;
  }

  function applyDifficulty(){
    brickHPMax = clamp(1 + Math.floor((level-1)/2), 1, 4);
    dropRate = clamp(0.18 + (level-1)*0.02, 0.18, 0.35);
    ballSpeedBase = clamp(560 + (level-1)*35, 560, 920);
    speedMult = 1 + (level-1)*0.06;
  }

  function buildLevel(){
    bricks = [];
    const rows = clamp(5 + Math.floor((level-1)*0.6), 5, 10);
    const cols = 10;
    const pad = 16;
    const top = 140;
    const bw = (W - pad*2 - (cols-1)*10) / cols;
    const bh = 34;

    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const hp = clamp(1 + Math.floor((Math.random()*brickHPMax)), 1, brickHPMax);
        const roll = Math.random();
        const special = (roll < 0.08) ? "steel" : (roll < 0.16 ? "glass" : "normal");
        bricks.push({
          x: pad + c*(bw+10),
          y: top + r*(bh+10),
          w: bw, h: bh,
          hp: (special==="steel") ? hp+2 : (special==="glass" ? 1 : hp),
          special
        });
      }
    }
    log(`레벨 ${level} 시작. 벽돌 ${bricks.length}개.`);
  }

  function newGame(){
    running=false; paused=false; over=false;
    score=0; level=1; life=3;
    clearAll();
    applyDifficulty();
    buildLevel();
    resetBall();
    statePill.textContent="대기";
    renderHUD();
    draw(); // 검정/빈 화면 방지
    log("새 게임 준비 완료.");
    toast("캔버스 탭 = 시작+발사");
  }

  function start(){
    if(over) return;
    if(!bricks.length) buildLevel();
    running=true; paused=false;
    statePill.textContent="진행 중";
  }

  function togglePause(){
    if(over) return;
    if(!running){ start(); return; }
    paused=!paused;
    statePill.textContent = paused ? "일시정지" : "진행 중";
  }

  function saveBest(){
    saveAll();
  }

  function onGameOver(){
    over=true; running=false; paused=false;
    statePill.textContent="GAME OVER";
    if(score > best){
      best = score;
      saveBest();
      toast("최고기록 갱신!");
      log(`최고기록 갱신: ${best}`);
    } else {
      toast("GAME OVER");
      log("게임 오버.");
    }
  }

  function onClearLevel(){
    running=false; paused=false;
    statePill.textContent="CLEAR!";
    const bonus = 500 * level;
    score += bonus;
    toast(`클리어! +${bonus}`);
    log(`레벨 ${level} 클리어! +${bonus}`);
    renderHUD();

    setTimeout(()=>{
      level++;
      clearAll();
      applyDifficulty();
      buildLevel();
      resetBall();
      statePill.textContent="대기";
      toast(`레벨 ${level} 준비`);
    }, 900);
  }

  function loseLife(){
    life--;
    log("공 놓침! 라이프 -1");
    if(life<=0){ onGameOver(); return; }
    resetBall();
  }

  // ===== Drops/Buffs =====
  const DROP_TYPES = ["multi","expand","slow","laser","shield","life"];
  function dropColor(id){
    const T = themeObj();
    const map = {
      multi: T.ball,
      expand: T.paddleGlow,
      slow: "rgba(251,191,36,.90)",
      laser: T.laser,
      shield: T.shield,
      life: "rgba(251,113,133,.92)"
    };
    return map[id] || "rgba(231,238,252,.92)";
  }
  function spawnDrop(x,y){
    const id = DROP_TYPES[(Math.random()*DROP_TYPES.length)|0];
    drops.push({ x,y,w:54,h:22,vy:220 + level*10,id });
  }
  function applyDrop(id){
    if(id==="multi"){
      let base = balls.find(b=>!b.stuck) || balls[0];
      const sx = base?.x ?? paddle.x;
      const sy = base?.y ?? (paddle.y-24);
      const sp = ballSpeedBase*speedMult;
      balls.push({x:sx, y:sy, r:10, vx: -sp*0.7, vy: -sp*0.7, stuck:false});
      balls.push({x:sx, y:sy, r:10, vx:  sp*0.7, vy: -sp*0.7, stuck:false});
      toast("멀티볼!");
    } else if(id==="expand"){
      buffs.expand.on=true; buffs.expand.t=14000; paddle.w = 260; toast("확장!");
    } else if(id==="slow"){
      buffs.slow.on=true; buffs.slow.t=12000; toast("슬로우!");
    } else if(id==="laser"){
      buffs.laser.on=true; buffs.laser.t=16000; buffs.laser.ammo += 12; toast("레이저!");
    } else if(id==="shield"){
      buffs.shield.on=true; buffs.shield.t=14000; toast("쉴드!");
    } else if(id==="life"){
      life += 1; toast("+1 라이프!");
    }
    log(`드랍: ${id}`);
  }
  function shootLaser(){
    if(!running || paused || over) return;
    if(!buffs.laser.on || buffs.laser.ammo<=0) return;
    buffs.laser.ammo--;
    lasers.push({ x:paddle.x, y:paddle.y-18, w:6, h:18, vy:-980 });
  }

  // ===== Physics =====
  function reflectBallOnPaddle(ball){
    const rel = (ball.x - paddle.x) / (paddle.w/2);
    const cl = clamp(rel, -1, 1);
    const speed = ballSpeedBase * speedMult * (buffs.slow.on ? 0.72 : 1);
    const angle = cl * (Math.PI * 0.38);
    ball.vx = speed * Math.sin(angle);
    ball.vy = -Math.abs(speed * Math.cos(angle));
  }
  function ballBrickCollision(ball, brick){
    const cx = clamp(ball.x, brick.x, brick.x+brick.w);
    const cy = clamp(ball.y, brick.y, brick.y+brick.h);
    const dx = ball.x - cx, dy = ball.y - cy;
    return (dx*dx + dy*dy) <= ball.r*ball.r;
  }
  function damageBrick(brick){
    brick.hp--;
    score += 10;
    if(brick.hp<=0){
      score += (brick.special==="steel") ? 25 : (brick.special==="glass" ? 20 : 15);
      if(Math.random() < dropRate) spawnDrop(brick.x + brick.w/2, brick.y + brick.h/2);
      bricks.splice(bricks.indexOf(brick), 1);
    }
  }

  function launchIfStuck(){
    if(!running || paused || over) return;
    for(const b of balls){
      if(b.stuck){
        const sp = ballSpeedBase * speedMult;
        const angle = rand(-0.55, 0.55);
        b.vx = sp * Math.sin(angle);
        b.vy = -Math.abs(sp * Math.cos(angle));
        b.stuck = false;
      }
    }
  }

  function update(dt){
    paddleTargetX = clamp(paddleTargetX, paddle.w/2 + 12, W - paddle.w/2 - 12);
    paddle.x += (paddleTargetX - paddle.x) * Math.min(1, dt*18);

    const tick = (b)=>{
      if(!b.on) return;
      b.t -= dt*1000;
      if(b.t <= 0) b.on = false;
    };
    tick(buffs.expand); tick(buffs.slow); tick(buffs.laser); tick(buffs.shield);
    if(!buffs.expand.on) paddle.w = 180;
    if(!buffs.laser.on) buffs.laser.ammo = 0;

    const ballSpeedFactor = (buffs.slow.on ? 0.72 : 1);

    for(const ball of balls){
      if(ball.stuck){
        ball.x = paddle.x; ball.y = paddle.y - 24;
        continue;
      }
      ball.x += ball.vx * dt * ballSpeedFactor;
      ball.y += ball.vy * dt * ballSpeedFactor;

      if(ball.x - ball.r < 10){ ball.x = 10 + ball.r; ball.vx *= -1; }
      if(ball.x + ball.r > W-10){ ball.x = W-10 - ball.r; ball.vx *= -1; }
      if(ball.y - ball.r < 10){ ball.y = 10 + ball.r; ball.vy *= -1; }

      const px1 = paddle.x - paddle.w/2, px2 = paddle.x + paddle.w/2;
      const py1 = paddle.y - paddle.h/2, py2 = paddle.y + paddle.h/2;
      if(ball.y + ball.r > py1 && ball.y - ball.r < py2 &&
         ball.x > px1-2 && ball.x < px2+2 && ball.vy > 0){
        ball.y = py1 - ball.r - 0.5;
        reflectBallOnPaddle(ball);
        score += 2;
      }

      if(buffs.shield.on){
        const shY = H - 22;
        if(ball.y + ball.r > shY && ball.vy > 0){
          ball.y = shY - ball.r - 0.5;
          ball.vy *= -1;
        }
      }

      for(const brick of bricks){
        if(ballBrickCollision(ball, brick)){
          const bx = brick.x, by = brick.y, bw=brick.w, bh=brick.h;
          const left = Math.abs((ball.x + ball.r) - bx);
          const right= Math.abs((bx + bw) - (ball.x - ball.r));
          const top  = Math.abs((ball.y + ball.r) - by);
          const bot  = Math.abs((by + bh) - (ball.y - ball.r));
          const m = Math.min(left,right,top,bot);
          if(m===left || m===right) ball.vx *= -1; else ball.vy *= -1;
          damageBrick(brick);
          score += 8;
          break;
        }
      }
    }

    for(let i=lasers.length-1;i>=0;i--){
      const l = lasers[i];
      l.y += l.vy * dt;
      if(l.y < -30){ lasers.splice(i,1); continue; }
      for(const brick of bricks){
        if(l.x > brick.x && l.x < brick.x+brick.w && l.y < brick.y+brick.h && l.y + l.h > brick.y){
          damageBrick(brick);
          score += 12;
          lasers.splice(i,1);
          break;
        }
      }
    }

    for(let i=drops.length-1;i>=0;i--){
      const d = drops[i];
      d.y += d.vy * dt;
      const px1 = paddle.x - paddle.w/2, px2 = paddle.x + paddle.w/2;
      const py1 = paddle.y - 30, py2 = paddle.y + 30;
      if(d.x > px1 && d.x < px2 && d.y > py1 && d.y < py2){
        applyDrop(d.id);
        drops.splice(i,1);
        continue;
      }
      if(d.y > H+40) drops.splice(i,1);
    }

    for(let i=balls.length-1;i>=0;i--){
      const b = balls[i];
      if(!b.stuck && b.y - b.r > H + 40) balls.splice(i,1);
    }
    if(balls.length===0) loseLife();
    if(bricks.length===0) onClearLevel();

    if(score > best){ best = score; saveAll(); }
    renderHUD();
  }

  // ===== Draw =====
  function roundRect(x,y,w,h,r,fill=true,stroke=false){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }

  function draw(){
    const T = themeObj();

    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = T.boardBG;
    ctx.fillRect(0,0,W,H);

    ctx.strokeStyle = T.frame;
    ctx.lineWidth = 3;
    roundRect(8,8,W-16,H-16,22,false,true);

    for(const b of bricks){
      const isSteel = b.special==="steel";
      const isGlass = b.special==="glass";
      const hp = b.hp;
      const base = isSteel ? T.steel : isGlass ? T.glass : T.brickPal[(hp-1) % T.brickPal.length];

      ctx.fillStyle = base;
      roundRect(b.x, b.y, b.w, b.h, 12, true, false);

      ctx.fillStyle = "rgba(255,255,255,.12)";
      roundRect(b.x+8, b.y+6, b.w-16, (b.h-14)*0.45, 10, true, false);

      ctx.strokeStyle = "rgba(0,0,0,.28)";
      ctx.lineWidth = 2;
      roundRect(b.x+1, b.y+1, b.w-2, b.h-2, 12, false, true);
    }

    for(const d of drops){
      const c = dropColor(d.id);
      ctx.fillStyle = "rgba(0,0,0,.22)";
      roundRect(d.x - d.w/2, d.y - d.h/2, d.w, d.h, 999, true, false);
      ctx.strokeStyle = c;
      ctx.lineWidth = 3;
      roundRect(d.x - d.w/2, d.y - d.h/2, d.w, d.h, 999, false, true);
      ctx.fillStyle = c;
      ctx.font = "900 16px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(d.id.toUpperCase().slice(0,2), d.x, d.y+0.5);
      ctx.textAlign = "start";
      ctx.textBaseline = "alphabetic";
    }

    for(const l of lasers){
      ctx.fillStyle = T.laser;
      roundRect(l.x - l.w/2, l.y, l.w, l.h, 4, true, false);
    }

    ctx.fillStyle = T.paddle;
    roundRect(paddle.x - paddle.w/2, paddle.y - paddle.h/2, paddle.w, paddle.h, 999, true, false);
    ctx.fillStyle = T.paddleGlow;
    roundRect(paddle.x - paddle.w/2 + 10, paddle.y - paddle.h/2 + 3, paddle.w - 20, paddle.h - 6, 999, true, false);

    if(buffs.shield.on){
      ctx.strokeStyle = T.shield;
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(20, H-22);
      ctx.lineTo(W-20, H-22);
      ctx.stroke();
    }

    for(const ball of balls){
      ctx.fillStyle = T.ball;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = T.ballGlow;
      ctx.beginPath();
      ctx.arc(ball.x-3, ball.y-4, ball.r*0.45, 0, Math.PI*2);
      ctx.fill();
    }

    if(paused || over || statePill.textContent==="CLEAR!"){
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillRect(0,0,W,H);
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.fillStyle="rgba(231,238,252,.92)";
      ctx.font="900 72px system-ui, sans-serif";
      const text = over ? "GAME OVER" : paused ? "PAUSED" : "CLEAR!";
      ctx.fillText(text, W/2, H/2 - 30);
      ctx.font="700 20px system-ui, sans-serif";
      ctx.fillStyle="rgba(155,176,208,.95)";
      ctx.fillText(over ? "새 게임 버튼으로 재시작" : paused ? "P 또는 버튼으로 재개" : "다음 레벨 준비 중…", W/2, H/2 + 40);
      ctx.textAlign="start";
      ctx.textBaseline="alphabetic";
    }
  }

  // ===== Inputs =====
  function clientXToCanvasX(clientX){
    const rect = cv.getBoundingClientRect();
    return (clientX - rect.left) / rect.width * W;
  }

  // ---- Touch drag for paddle ----
  let touchDragging = false;

  // Tap detect (캔버스 탭 = 시작+발사)
  let tapStartX = 0, tapStartY = 0, tapStartT = 0;

  cv.addEventListener("touchstart", (e)=>{
    e.preventDefault();
    const t = e.changedTouches[0];
    touchDragging = true;
    paddleTargetX = clientXToCanvasX(t.clientX);

    tapStartX = t.clientX;
    tapStartY = t.clientY;
    tapStartT = performance.now();
  }, {passive:false});

  cv.addEventListener("touchmove", (e)=>{
    e.preventDefault();
    if(!touchDragging) return;
    const t = e.changedTouches[0];
    paddleTargetX = clientXToCanvasX(t.clientX);
  }, {passive:false});

  cv.addEventListener("touchend", (e)=>{
    e.preventDefault();
    touchDragging = false;

    const t = e.changedTouches[0];
    const dx = Math.abs(t.clientX - tapStartX);
    const dy = Math.abs(t.clientY - tapStartY);
    const dt = performance.now() - tapStartT;

    const isTap = (dx < 10 && dy < 10 && dt < 250);
    if(isTap){
      start();
      launchIfStuck();
      toast("발사!");
    }
  }, {passive:false});

  // Mouse (PC)
  cv.addEventListener("mousemove", (e)=>{
    paddleTargetX = clientXToCanvasX(e.clientX);
  });

  // Keyboard (PC)
  window.addEventListener("keydown", (e)=>{
    if(["ArrowLeft","ArrowRight"," ","p","P"].includes(e.key)) e.preventDefault();
    keys.add(e.key);
    if(e.key===" "){
      if(over){ newGame(); start(); return; }
      start();
      launchIfStuck();
    }
    if(e.key==="p"||e.key==="P") togglePause();
  }, {passive:false});
  window.addEventListener("keyup", (e)=> keys.delete(e.key));

  // Buttons
  $("btnStart").addEventListener("click", ()=>{ start(); toast("시작"); });
  $("btnPause").addEventListener("click", ()=>togglePause());
  $("btnNew").addEventListener("click", ()=>newGame());
  $("btnResetBest").addEventListener("click", ()=>{
    if(!confirm("최고 기록을 초기화할까요?")) return;
    best = 0; saveAll(); renderHUD(); toast("기록 초기화");
  });
  $("btnLeft").addEventListener("click", ()=>{ paddleTargetX -= 120; });
  $("btnRight").addEventListener("click", ()=>{ paddleTargetX += 120; });
  $("btnShoot").addEventListener("click", ()=>{ start(); launchIfStuck(); toast("발사!"); });
  $("btnRestart").addEventListener("click", ()=>{ if(over) { newGame(); } else { start(); launchIfStuck(); } });
  $("btnLaser").addEventListener("click", ()=>{ shootLaser(); });

  // iOS/인앱브라우저에서 click 씹힘 대비: touchstart도 추가
  $("btnStart").addEventListener("touchstart", (e)=>{ e.preventDefault(); start(); toast("시작"); }, {passive:false});
  $("btnShoot").addEventListener("touchstart", (e)=>{ e.preventDefault(); start(); launchIfStuck(); toast("발사!"); }, {passive:false});
  $("btnPause").addEventListener("touchstart", (e)=>{ e.preventDefault(); togglePause(); }, {passive:false});
  $("btnLaser").addEventListener("touchstart", (e)=>{ e.preventDefault(); shootLaser(); }, {passive:false});
  $("btnLeft").addEventListener("touchstart", (e)=>{ e.preventDefault(); paddleTargetX -= 120; }, {passive:false});
  $("btnRight").addEventListener("touchstart", (e)=>{ e.preventDefault(); paddleTargetX += 120; }, {passive:false});
  $("btnRestart").addEventListener("touchstart", (e)=>{ e.preventDefault(); if(over){ newGame(); } else { start(); launchIfStuck(); } }, {passive:false});

  // ===== Main Loop =====
  function loop(ts){
    const dt = Math.min(0.05, Math.max(0, (ts - lastTs)/1000));
    lastTs = ts;

    if(running && !paused && !over){
      update(dt);
    } else {
      paddleTargetX = clamp(paddleTargetX, paddle.w/2 + 12, W - paddle.w/2 - 12);
      paddle.x += (paddleTargetX - paddle.x) * Math.min(1, dt*18);
      for(const b of balls){
        if(b.stuck){
          b.x = paddle.x;
          b.y = paddle.y - 24;
        }
      }
      renderHUD();
    }

    draw();
    requestAnimationFrame(loop);
  }

  // ===== Init =====
  bestEl.textContent = best|0;
  newGame();
  log("모바일: 캔버스 탭/발사 버튼으로 발사 가능");
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
